




//AUTOGENERATED, DO NOTMODIFY.
//Do not edit this file directly.

#pragma warning disable 1591
// ReSharper disable CheckNamespace

using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using RethinkDb.Driver.Model;
using RethinkDb.Driver.Ast;
using NUnit.Framework;
using RethinkDb.Driver.Tests;

namespace RethinkDb.Driver.Test.Generated {
    [TestFixture]
    public class TimesTimeArith : GeneratedTest {

        public TimesTimeArith (){
        }




        [Test]
        public void YamlTest(){

             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: rt1 = 1375147296.681
             
var rt1 = (double) (1375147296.681);             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: rt2 = 1375147296.682
             
var rt2 = (double) (1375147296.682);             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: rt3 = 1375147297.681
             
var rt3 = (double) (1375147297.681);             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: rt4 = 2375147296.681
             
var rt4 = (double) (2375147296.681);             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: rts = [rt1, rt2, rt3, rt4]
             
var rts = (IList) (r.array(rt1, rt2, rt3, rt4));             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: t1 = r.epoch_time(rt1)
             
var t1 = (EpochTime) (r.epochTime(rt1));             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: t2 = r.epoch_time(rt2)
             
var t2 = (EpochTime) (r.epochTime(rt2));             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: t3 = r.epoch_time(rt3)
             
var t3 = (EpochTime) (r.epochTime(rt3));             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: t4 = r.epoch_time(rt4)
             
var t4 = (EpochTime) (r.epochTime(rt4));             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: ts = r.expr([t1, t2, t3, t4])
             
var ts = (MakeArray) (r.expr(r.array(t1, t2, t3, t4)));             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #11
                 /* ExpectedOriginal: True */
                 var expected_ = true;
                 
                 /* Original: ((t2 - t1) * 1000).do(lambda x:(x > 0.99) & (x < 1.01)) */
                 var obtained = runOrCatch( r.sub(t2, t1).mul(1000L).do_(x => r.gt(x, 0.99).and(r.lt(x, 1.01))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #12
                 /* ExpectedOriginal: 1 */
                 var expected_ = 1L;
                 
                 /* Original: t3 - t1 */
                 var obtained = runOrCatch( r.sub(t3, t1) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #13
                 /* ExpectedOriginal: 1000000000 */
                 var expected_ = 1000000000L;
                 
                 /* Original: t4 - t1 */
                 var obtained = runOrCatch( r.sub(t4, t1) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #14
                 /* ExpectedOriginal: True */
                 var expected_ = true;
                 
                 /* Original: ((t1 - t2) * 1000).do(lambda x:(x < -0.99) & (x > -1.01)) */
                 var obtained = runOrCatch( r.sub(t1, t2).mul(1000L).do_(x => r.lt(x, -0.99).and(r.gt(x, -1.01))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #15
                 /* ExpectedOriginal: -1 */
                 var expected_ = -1L;
                 
                 /* Original: t1 - t3 */
                 var obtained = runOrCatch( r.sub(t1, t3) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #16
                 /* ExpectedOriginal: -1000000000 */
                 var expected_ = -1000000000L;
                 
                 /* Original: t1 - t4 */
                 var obtained = runOrCatch( r.sub(t1, t4) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #17
                 /* ExpectedOriginal: ([rt1, rt2, rt3, rt4]) */
                 var expected_ = r.array(rt1, rt2, rt3, rt4);
                 
                 /* Original: ts.map(lambda x:t1 + (x - t1)).map(lambda x:x.to_epoch_time()) */
                 var obtained = runOrCatch( ts.map(x => r.add(t1, r.sub(x, t1))).map(x => x.toEpochTime()) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #18
                 /* ExpectedOriginal: err("ReqlQueryLogicError", "Expected type NUMBER but found PTYPE<TIME>.", []) */
                 var expected_ = err("ReqlQueryLogicError", "Expected type NUMBER but found PTYPE<TIME>.", r.array());
                 
                 /* Original: ts.map(lambda x:(t1 + x) - t1).map(lambda x:x.to_epoch_time()) */
                 var obtained = runOrCatch( ts.map(x => r.add(t1, x).sub(t1)).map(x => x.toEpochTime()) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #19
                 /* ExpectedOriginal: ([rt1, rt2, rt3, rt4]) */
                 var expected_ = r.array(rt1, rt2, rt3, rt4);
                 
                 /* Original: ts.map(lambda x:t1 - (t1 - x)).map(lambda x:x.to_epoch_time()) */
                 var obtained = runOrCatch( ts.map(x => r.sub(t1, r.sub(t1, x))).map(x => x.toEpochTime()) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #20
                 /* ExpectedOriginal: ([[[false, true,  true,  false, true,  false], [true,  true,  false, true,  false, false], [true,  true,  false, true,  false, false], [true,  true,  false, true,  false, false]], [[false, false, false, true,  true,  true], [false, true,  true,  false, true,  false], [true,  true,  false, true,  false, false], [true,  true,  false, true,  false, false]], [[false, false, false, true,  true,  true], [false, false, false, true,  true,  true], [false, true,  true,  false, true,  false], [true,  true,  false, true,  false, false]], [[false, false, false, true,  true,  true], [false, false, false, true,  true,  true], [false, false, false, true,  true,  true], [false, true,  true,  false, true,  false]]]) */
                 var expected_ = r.array(r.array(r.array(false, true, true, false, true, false), r.array(true, true, false, true, false, false), r.array(true, true, false, true, false, false), r.array(true, true, false, true, false, false)), r.array(r.array(false, false, false, true, true, true), r.array(false, true, true, false, true, false), r.array(true, true, false, true, false, false), r.array(true, true, false, true, false, false)), r.array(r.array(false, false, false, true, true, true), r.array(false, false, false, true, true, true), r.array(false, true, true, false, true, false), r.array(true, true, false, true, false, false)), r.array(r.array(false, false, false, true, true, true), r.array(false, false, false, true, true, true), r.array(false, false, false, true, true, true), r.array(false, true, true, false, true, false)));
                 
                 /* Original: ts.map(lambda x:ts.map(lambda y:[x < y, x <= y, x == y, x != y, x >= y, x > y])) */
                 var obtained = runOrCatch( ts.map(x => ts.map(y => r.array(r.lt(x, y), r.le(x, y), r.eq(x, y), r.ne(x, y), r.ge(x, y), r.gt(x, y)))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             
             //JavaDef, times/time_arith.yaml, #Templates.YamlTest+DefTest.
             //Original: datum_types = r.expr([null, true, false, 1, "1", [1], {"1":1}, r.binary(b'')])
             
var datum_types = (MakeArray) (r.expr(r.array(null, true, false, 1L, "1", r.array(1L), r.hashMap("1", 1L), r.binary(new byte[] {}))));             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #22
                 /* ExpectedOriginal: ([[[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[false, false, false, true,  true,  true], [true,  true,  false, true,  false, false]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]], [[true,  true,  false, true,  false, false], [false, false, false, true,  true,  true]]]) */
                 var expected_ = r.array(r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(false, false, false, true, true, true), r.array(true, true, false, true, false, false)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)), r.array(r.array(true, true, false, true, false, false), r.array(false, false, false, true, true, true)));
                 
                 /* Original: datum_types.map(lambda x:r.expr([[x, t1], [t1, x]]).map(lambda xy:xy[0].do(lambda x2:xy[1].do(lambda y:[x2 < y, x2 <= y, x2 == y, x2 != y, x2 >= y, x2 > y])))) */
                 var obtained = runOrCatch( datum_types.map(x => r.expr(r.array(r.array(x, t1), r.array(t1, x))).map(xy => xy.nth(0L).do_(x2 => xy.nth(1L).do_(y => r.array(r.lt(x2, y), r.le(x2, y), r.eq(x2, y), r.ne(x2, y), r.ge(x2, y), r.gt(x2, y)))))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #23
                 /* ExpectedOriginal: ([[[false, true,  true,  true], [false, false, true,  true], [false, false, false, true], [false, false, false, false]], [[false, false, false, false], [false, false, true,  true], [false, false, false, true], [false, false, false, false]], [[false, false, false, false], [false, false, false, false], [false, false, false, true], [false, false, false, false]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, false]]]) */
                 var expected_ = r.array(r.array(r.array(false, true, true, true), r.array(false, false, true, true), r.array(false, false, false, true), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, true, true), r.array(false, false, false, true), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, true), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false)));
                 
                 /* Original: ts.map(lambda a:ts.map(lambda b:ts.map(lambda c:b.during(a, c)))) */
                 var obtained = runOrCatch( ts.map(a => ts.map(b => ts.map(c => b.during(a, c)))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #24
                 /* ExpectedOriginal: ([[[false, false, false, false], [false, false, true,  true], [false, false, false, true], [false, false, false, false]], [[false, false, false, false], [false, false, false, false], [false, false, false, true], [false, false, false, false]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, false]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, false]]]) */
                 var expected_ = r.array(r.array(r.array(false, false, false, false), r.array(false, false, true, true), r.array(false, false, false, true), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, true), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false)));
                 
                 /* Original: ts.map(lambda a:ts.map(lambda b:ts.map(lambda c:b.during(a, c, left_bound='open')))) */
                 var obtained = runOrCatch( ts.map(a => ts.map(b => ts.map(c => b.during(a, c).optArg("left_bound", "open")))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #25
                 /* ExpectedOriginal: ([[[true,  true,  true,  true], [false, true,  true,  true], [false, false, true,  true], [false, false, false, true]], [[false, false, false, false], [false, true,  true,  true], [false, false, true,  true], [false, false, false, true]], [[false, false, false, false], [false, false, false, false], [false, false, true,  true], [false, false, false, true]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, true]]]) */
                 var expected_ = r.array(r.array(r.array(true, true, true, true), r.array(false, true, true, true), r.array(false, false, true, true), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, true, true, true), r.array(false, false, true, true), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, true, true), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, true)));
                 
                 /* Original: ts.map(lambda a:ts.map(lambda b:ts.map(lambda c:b.during(a, c, right_bound='closed')))) */
                 var obtained = runOrCatch( ts.map(a => ts.map(b => ts.map(c => b.during(a, c).optArg("right_bound", "closed")))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #26
                 /* ExpectedOriginal: ([[[false, false, false, false], [false, true,  true,  true], [false, false, true,  true], [false, false, false, true]], [[false, false, false, false], [false, false, false, false], [false, false, true,  true], [false, false, false, true]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, true]], [[false, false, false, false], [false, false, false, false], [false, false, false, false], [false, false, false, false]]]) */
                 var expected_ = r.array(r.array(r.array(false, false, false, false), r.array(false, true, true, true), r.array(false, false, true, true), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, true, true), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, true)), r.array(r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false), r.array(false, false, false, false)));
                 
                 /* Original: ts.map(lambda a:ts.map(lambda b:ts.map(lambda c:b.during(a, c, left_bound='open', right_bound='closed')))) */
                 var obtained = runOrCatch( ts.map(a => ts.map(b => ts.map(c => b.during(a, c).optArg("left_bound", "open").optArg("right_bound", "closed")))) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #27
                 /* ExpectedOriginal: rts */
                 var expected_ = rts;
                 
                 /* Original: ts.map(lambda x:x.date() + x.time_of_day()).map(lambda x:x.to_epoch_time()) */
                 var obtained = runOrCatch( ts.map(x => x.date().add(x.timeOfDay())).map(x => x.toEpochTime()) ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #28
                 /* ExpectedOriginal: rt1 */
                 var expected_ = rt1;
                 
                 /* Original: r.epoch_time(rt1).do(r.js("(function(data){return data})")).to_epoch_time() */
                 var obtained = runOrCatch( r.epochTime(rt1).do_(r.js("(function(data){return data})")).toEpochTime() ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #29
                 /* ExpectedOriginal: ("2012-08-01T00:00:00+00:00") */
                 var expected_ = "2012-08-01T00:00:00+00:00";
                 
                 /* Original: r.do(r.js("new Date('2012-08-01')")).to_iso8601() */
                 var obtained = runOrCatch( r.do_(r.js("new Date('2012-08-01')")).toIso8601() ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             
             TestCounter++;
             
             {
                 //JavaQuery, times/time_arith.yaml, #30
                 /* ExpectedOriginal: ("2012-08-01T00:00:00+00:00") */
                 var expected_ = "2012-08-01T00:00:00+00:00";
                 
                 /* Original: r.do(r.js("(function(x){doc = new Object(); doc.date = new Date('2012-08-01'); return doc;})"))["date"].to_iso8601() */
                 var obtained = runOrCatch( r.do_(r.js("(function(x){doc = new Object(); doc.date = new Date('2012-08-01'); return doc;})")).g("date").toIso8601() ,
                                            new OptArgs()
                    );
                 assertEquals(expected_, obtained);
             }
             

        }
    }
}
