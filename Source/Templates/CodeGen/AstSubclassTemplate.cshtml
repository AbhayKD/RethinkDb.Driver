@* Generator: Template  GeneratePrettyNames: true *@
@using System
@using System.Collections.Generic
@using System.Linq
@using System.Security.Cryptography
@using System.Text
@using Humanizer
@using Newtonsoft.Json
@using Newtonsoft.Json.Linq
@using RazorGenerator.Templating
@using Templates.CodeGen
@using Templates.CodeGen.Util
@using Templates.Metadata
@using Z.ExtensionMethods

@inherits BaseTemplate

@functions {
    public string ClassName { get; set; }
    public string Superclass { get; set; }

    public string TermName { get; set; }
    public JObject TermMeta { get; set; }
    public Dictionary<string,JObject> AllTerms { get; set; }

    public override RazorTemplateBase UseParentLayout(RazorTemplateBase child)
    {
        return new AstSubclassTemplate()
        {
            ClassName = this.ClassName,
            Superclass = this.Superclass,
            TermName = this.TermName,
            TermMeta = this.TermMeta,
            AllTerms = this.AllTerms,
            ChildTemplate = child
        };
    }
}

@helper RenderCtorXmlDoc(string term)
{   
    Documentation doc;
    if( MetaDb.Docs.TryGetValue(term, out doc) )
    {
@:/// <summary>
@:/// @doc.Description
@:/// </summary>
@:/// <example>@doc.Example</example>
    };
}

@section Ctors{
    @if( this.TermName != null )
    {
        @RenderCtorXmlDoc(this.TermName)
        @:public @Class(ClassName) (object arg) : this(new Arguments(arg), null) {
        @:}

        @RenderCtorXmlDoc(this.TermName)
        @:public @Class(ClassName) (Arguments args) : this(args, null) {
        @:}

        @RenderCtorXmlDoc(this.TermName)
        @:public @Class(ClassName) (Arguments args, OptArgs optargs)
        @:     : this(TermType.@TermName, args, optargs) {
        @:}
    }

    protected @Class(ClassName) (TermType termType, Arguments args, OptArgs optargs) : base(termType, args, optargs)
    {
    }
}

@section StaticFactories{

}

@section OptArgs{
    @if( TermMeta?["optargs"] != null )
    {
        var optArgs = TermMeta["optargs"] as JObject;
@:///<summary>
@:/// @optArgs.ToString().Trim('{', '}').Trim().Replace("\n","\n///")
@:///</summary>
        @:public @Class(ClassName) optArg(string optname, object value) {
        @:     var newOptargs = OptArgs.fromMap(this.OptArgs)
        @:                             .with(optname, value);
        @:     return new @Class(ClassName) (this.Args, newOptargs);
        @:}
     }
}

//AUTOGENERATED, DO NOTMODIFY.
//Do not edit this file directly.

#pragma warning disable 1591
// ReSharper disable CheckNamespace

using System;
using RethinkDb.Driver.Ast;
using RethinkDb.Driver.Model;
using RethinkDb.Driver.Proto;
using System.Collections.Generic;
@RenderSection("add_imports")

namespace RethinkDb.Driver.Ast {

    public class @Class(ClassName) : @Superclass {

    @RenderSection("MemberVars")
    
    @RenderSection("Ctors")

    @RenderSection("StaticFactories")

    @RenderSection("OptArgs")

    @RenderBody()

    @RenderSection("SpecialMethods")

    @foreach( var termInfo in AllTerms )
    {
        var term = termInfo.Key;
        var info = termInfo.Value;


        if( info["include_in"].ToObject<string[]>().Any(inc => string.Equals(inc, ClassName, StringComparison.OrdinalIgnoreCase)) )
        { // is the current term included in this class we're generating?

            foreach(var signature in info["signatures"].ToObject<Signature[]>() )
            {
                if( signature.FirstArg == ClassName )
                {
                    var parameters = signature.Args.Skip(1).Select(arg => $"{ArgumentType(arg.Type)} {ArgumentVariable(arg.Var)}").ToArray();
                    @RenderCtorXmlDoc(term)
                    @:public @Class(info["classname"].ToString()) @Method(info["methodname"].ToString()) ( @string.Join(", ", parameters.ToArray()) )
                    @:{

                        @:Arguments arguments = new Arguments(this);
                    foreach( var param in signature.Args.Skip(1) )
                    {
                        if( param.Type == "Object..." )
                        {
                        @:arguments.CoerceAndAddAll(@ArgumentVariable(param.Var));
                        }
                        else
                        {
                        @:arguments.CoerceAndAdd(@ArgumentVariable(param.Var));
                        }
                    }
                        @:return new @Class(info["classname"].ToString()) (arguments);

                    @:}
                }
            }

        }
    }

    
    }
}
