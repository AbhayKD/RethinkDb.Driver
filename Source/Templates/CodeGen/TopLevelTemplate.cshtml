@using System.Collections.Generic
@using System.Linq
@using Humanizer
@using Newtonsoft.Json.Linq
@using Templates.CodeGen.Util
@using Templates.Metadata
@using Z.ExtensionMethods

@inherits Templates.CodeGen.BaseTemplate

@functions {
    public Dictionary<string, JObject> AllTerms { get; set; }

}

@helper RenderMethodXmlDoc(string term)
{
    Documentation doc;
    if (MetaDb.Docs.TryGetValue(term, out doc))
    {
@:/// <summary>
@:/// @doc.Description
@:///</summary>
@:/// <example>@doc.Example</example>
    };
}




//AUTOGENERATED, DO NOTMODIFY.
//Do not edit this file directly.

#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
// ReSharper disable CheckNamespace

using System;
using System.Linq;
using System.Collections;
using RethinkDb.Driver.Model;
using RethinkDb.Driver.Ast;

namespace RethinkDb.Driver.Ast {
    public class TopLevel {

        public ReqlExpr Expr(Object value){
            return Util.ToReqlExpr(value);

        }
        internal ReqlExpr expr(Object value){
            return Expr(value);
        }


        public ReqlExpr Row(params object[] values) {
            throw new ReqlDriverError("r.row is not implemented in the C# driver. Use lambda syntax instead.");
        }
        internal ReqlExpr row(params object[] values) {
            return Row(values);
        }

        public MapObject HashMap(object key, object val) {
            return new MapObject().With(key, val);
        }
        internal MapObject hashMap(object key, object val) {
            return new MapObject().With(key, val);
        }

        public MapObject HashMap()
        {
            return new MapObject();
        }
        internal MapObject hashMap()
        {
            return HashMap();
        }


        public IList Array(params object[] values){
            return values.ToList();
        }
        internal IList array(params object[] values){
            return Array(values);
        }

        @foreach (var termInfo in AllTerms)
        {
            var term = termInfo.Value;
            if (term["include_in"].ToObject<string[]>().Any(inc => string.Equals(inc, "TopLevel")))
            {
                foreach( var methodname in term["methodnames"].ToObject<string[]>() )
                {
                    foreach( var sig in term["signatures"].ToObject<Signature[]>() )
                    {
                        if( sig.FirstArg.NotIn("Db", "Table") )
                        {
                            var parameters = sig.Args.Select(arg => $"{ArgumentType(arg.Type)} {ArgumentVariable(arg.Var)}").ToArray();
                            var forwardParams = sig.Args.Select(arg => $"{ArgumentVariable(arg.Var)}").ToArray();

                            @RenderMethodXmlDoc(termInfo.Key)
                            @:public @Class(term["classname"].ToString()) @Method(methodname) ( @string.Join(", ", parameters.ToArray()) )
                            @:{

                            if (methodname == "binary")
                            {
                                var firstArg = sig.Args[0].Var;
                                @:   var byteArray = @firstArg as byte[];
                                @:   if( byteArray != null ){
                                @:     return new Binary(byteArray);
                                @:   }
                            }
                            @:    Arguments arguments = new Arguments();
                            foreach( var param in sig.Args )
                            {
                                if( param.Type == "Object..." )
                                {
                                @:arguments.CoerceAndAddAll(@ArgumentVariable(param.Var));
                                }
                                else
                                {
                                @:arguments.CoerceAndAdd(@ArgumentVariable(param.Var));
                                }
                            }
                            @:    return new @Class(term["classname"].ToString()) (arguments);
                            @:}

                            @:internal @Class(term["classname"].ToString()) @MethodInternalName(methodname) ( @string.Join(", ", parameters.ToArray()) )
                            @:{
                            @:   return @Method(methodname) ( @string.Join(", ", forwardParams.ToArray()) );
                            @:}
                        }
                    }
                }
            }
        }



    }
}
